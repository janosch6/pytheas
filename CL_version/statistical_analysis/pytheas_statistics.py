#!/usr/bin/env python3

"""
Last update: April 2021
Author: Luigi D'Ascenzo, PhD - The Scripps Research Institute, La Jolla (CA)
Contact info: dascenzoluigi@gmail.com
GitHub project repository: https://github.com/ldascenzo/pytheas

***DESCRIPTION***
Pytheas statistical analysis tools. Given information on target and decoy sequences (obtained from the matching and
scoring step), relevant statistical plots are generated. More information on the parameters and the output plots
can be found in the Pytheas manual.

OPTIONS
--targets_csv (Required) -> Input csv file containing target sequences (targets_[dataset]) (Required)
--decoys_csv  (Required) -> Input csv file containing decoy sequences (decoys_[dataset]) (Required)
--match_file (Required) -> File (txt) generated by the Pytheas matching and scoring algorithm (required)
--isotopic_species (Optional) -> Isotopically labeled (heavy) or unlabeled (light) sequences to include in the '
                             'statistical plots. By default, both are included (Optional)
--FDR_input (Optional, if FDR is requested on scatterplots) -> FDR analysis file use to draw FDR lines on certain
                                                                statistical plots (Optional)
--y_min (Optional, default = auto) -> Minimum value for the y axis for visualization on scatter plots with Sp vs nts
--y_max (Optional, default = auto) -> Maximum value for the y axis for visualization on scatter plots with Sp vs nts
--lengths (Optional, default = all - NOTE: use without '=' and with no comma between values) -> Input the nucleotide
  lenght for the fragments to be used for statistical analysis. Option is not applied for the ppm offset histogram
--Sp_cutoff (Optional, default = 0) -> Sp score minimum cutoff to select target sequences for the statistical plots'
                         (Optional, default = 0)
--only_targets_with_decoys (Optional, default = y) -> Select (y/n) if only targets with at least one decoy will be
  used for the scatterplots and boxplots
--info_box (Optional, default = y) -> Show (y/n) green boxes with info (statistics, parameters...) on the plots '
                         '(Optional, default = y)
--scatterplot_Sp_vs_dSp (Optional, default = n) -> Generate(y/n) an additional scatter plot with Sp scores vs dSp
                                                    for targets/decoys'
--scatterbox_lengths_z (Optional, default = n) -> Generate a scatterplot/boxplot of the distribution of Sp scores vs
                                                 length&charge for targets/decoys



"""

import os, sys
import pandas as pd
import argparse
import stats_tools as stats
import matplotlib.pyplot as plt
import numpy as np
import matplotlib as mpl
import ntpath

# Initialize and define launch options
parser = argparse.ArgumentParser(description='List of available options')
parser.add_argument('--targets_csv', required=True,
                    help='Input csv file containing target sequences (targets_[dataset]) (Required)')
parser.add_argument('--decoys_csv', required=True, help='Input csv file containing decoy sequences '
                                                        '(decoys_[dataset]) (Required)')
parser.add_argument('--match_file', required=True, help='File (txt) generated by the Pytheas matching and scoring '
                                                        'algorithm (required)')
parser.add_argument('--isotopic_species', default='all', choices=['all', 'light', 'heavy'],
                    help='Isotopically labeled (heavy) or unlabeled (light) sequences to include in the '
                             'statistical plots. By default, both are included (Optional)')
parser.add_argument('--FDR_input', default=None,
                    help='FDR analysis file use to draw FDR lines on certain statistical plots (Optional)')
parser.add_argument('--y_min', default=0, type=np.float64,
                    help='Minimum value for the y axis for visualization on scatter plots with Sp vs nts '
                         '(Optional, default = auto)')
parser.add_argument('--y_max', default=0, type=np.float64,
                    help='Maximum value for the y axis for visualization on scatter plots with Sp vs nts '
                         '(Optional, default = auto)')
parser.add_argument('--lengths', nargs='*', default=["all"], type=int,
                    help='Input the nucleotide lenght for the fragments to be used for statistical analysis. '
                         'Option is not used for ppm offset histogram (Optional, default = all)')
parser.add_argument('--Sp_cutoff', default=0, type=np.float64,
                    help='Sp score minimum cutoff to select target sequences for the statistical plots'
                         ' (Optional, default = 0)')
parser.add_argument('--only_targets_with_decoys', default='y', choices=['y', 'n'],
                    help='Select (y/n) if only targets with at least one decoy will be used for the scatterplots '
                         'and boxplots (Optional, default = y)')
parser.add_argument('--info_box', default='y', choices=['y', 'n'],
                    help='Show (y/n) green boxes with info (statistics, parameters...) on the plots '
                         '(Optional, default = y)')
parser.add_argument('--scatterplot_Sp_vs_dSp', default='n', choices=['y', 'n'],
                        help='Generate(y/n) an additional scatter plot with Sp scores vs dSp for targets/decoys'
                             '(Optional, default = n)')
parser.add_argument('--scatterbox_lengths_z', default='n', choices=['y', 'n'],
                        help='Generate a scatterplot/boxplot of the distribution of Sp scores vs length&charge for'
                             'targets/decoys (Optional, default = n)')


args = parser.parse_args()

# Publication-quality settings for the graphs
plt.style.use('ggplot')
plt.rc('font', family='serif')
mpl.rcParams['axes.titlesize'] = 7
mpl.rcParams['axes.titleweight'] = 'bold'
mpl.rcParams['axes.labelsize'] = 5
mpl.rcParams['xtick.labelsize'] = 5
mpl.rcParams['ytick.labelsize'] = 5
mpl.rcParams['legend.fontsize'] = 5
mpl.rcParams['legend.fancybox'] = True
mpl.rcParams['font.size'] = 5
mpl.rcParams['axes.facecolor'] = 'whitesmoke'
pd.options.mode.chained_assignment = None


def read_csv_input(csv_file, isotopes):
    """
    Read the csv input file creating a pandas dataframe
    Uses the matches from the light, heavy channel or both based on the user preferences
    """
    df = pd.read_csv(csv_file)

    # Applies the filter of light/heavy ions specified by the user
    if isotopes == 'light':
        df = df[df['isotope'] == 'light']
    elif isotopes == 'heavy':
        df = df[df['isotope'] == 'heavy']
    else:
        pass

    return df


def save_graph(namefile):
    """
    Save the matplotlib graphs and creates copies of already existing files
    """
    if os.path.exists(namefile):
        numbers = list(range(100))
        for n in numbers:
            if not os.path.exists("_".join(namefile.split("_")[:-1]) + "_{}.png".format(n)):
                plt.savefig("_".join(namefile.split("_")[:-1]) + "_{}.png".format(n), bbox_inches='tight', dpi=300)
                break

    else:
        plt.savefig(namefile, bbox_inches='tight', dpi=300)


def graphs_plot():
    """
    Plot the graphs from the input csv data
    """
    csv_files = (read_csv_input(args.targets_csv, args.isotopic_species),
                 read_csv_input(args.decoys_csv, args.isotopic_species))

    if csv_files[0].empty:
        print("ERROR! CSV input file {} is empty. Execution terminated without generating any output".format(
            args.targets_csv))
        sys.exit(1)

    name_input = filename_from_path(args.targets_csv)[8:-4]

    # Histogram with the distribution of ppm error offsets for MS1 and MS2 matches
    plt.subplot(2, 1, 1)
    stats.ppm_errors_histogram(csv_files, args.Sp_cutoff, 'MS1', args.match_file, args.info_box)

    plt.subplot(2, 1, 2)
    stats.ppm_errors_histogram(csv_files, args.Sp_cutoff, 'MS2', args.match_file, args.info_box)
    save_graph("Hist_ppm_offset_{}.png".format(name_input))
    plt.close()

    # Histogram with the distribution of the Sp scores for targets/decoys and top target/decoys
    plt.subplot(2, 1, 1)
    stats.hist_Sp(csv_files, args.lengths, args.Sp_cutoff, args.only_targets_with_decoys, args.info_box)

    plt.subplot(2, 1, 2)
    stats.hist_top_Sp(csv_files, args.lengths, args.Sp_cutoff, args.only_targets_with_decoys, args.info_box)
    plt.subplots_adjust(hspace=0.25)
    save_graph("Hist_Sp_{}.png".format(name_input))
    plt.close()

    # Histogram with the distribution of the dSp values for the second best targets
    stats.hist_second_dSp(csv_files, args.lengths, args.Sp_cutoff, args.only_targets_with_decoys, args.info_box)
    save_graph("Hist_dSp2_{}.png".format(name_input))
    plt.close()

    # Scatter + boxplot of the Sp scores vs the matches ions length
    plt.subplot(2, 1, 1)
    stats.scatter_nts_vs_score(csv_files, 'Sp', args.y_min, args.y_max, args.lengths, args.Sp_cutoff, args.info_box,
                               args.only_targets_with_decoys)
    plt.subplot(2, 1, 2)
    stats.box_nts_vs_score(csv_files, 'Sp', args.y_min, args.y_max, args.lengths, args.Sp_cutoff,
                           args.only_targets_with_decoys)

    save_graph("Scatterbox_Sp_length_{}.png".format(name_input))
    plt.close()

    if args.scatterbox_lengths_z == 'y':
        # Scatter + boxplot of the Sp scores vs the matches ions length grouped by charge
        try:
            plt.subplot(2, 1, 1)
            stats.scatter_nts_z_vs_score(csv_files, 'Sp', args.y_min, args.y_max, args.lengths, args.Sp_cutoff,
                                         args.only_targets_with_decoys)
            plt.subplot(2, 1, 2)
            stats.box_nts_z_vs_score(csv_files, 'Sp', args.y_min, args.y_max, args.lengths, args.Sp_cutoff,
                                     args.only_targets_with_decoys)
            save_graph("Scatterbox_Sp_length_z_{}.png".format(name_input))
            plt.close()

        except:
            print('Scatter + boxplots of Sp scores of matches vs length grouped by charge could not be produced. '
                  'This is probably due to the parameters chosen')

    # Additional graphs are plotted only if the decoys csv file is not empty
    if not csv_files[1].empty:
        # Scatter plot of Sp of targets vs Sp of decoys of the given targets
        stats.scatter_Sp_vs_Spdecoy(csv_files, args.lengths, args.Sp_cutoff, args.info_box)
        save_graph("Scatter_Sp_Spdecoy_{}.png".format(name_input))
        plt.close()

        # Scatter plot of Sp of targets vs Sp of decoys of the given targets, divided by nucleotide
        # lengths of precursors
        stats.scatter_Sp_vs_Spdecoy(csv_files, ['analysis'], args.Sp_cutoff, args.info_box)
        save_graph("Scatter_Sp_Spdecoy_bylength_{}.png".format(name_input))
        plt.close()

        if args.scatterplot_Sp_vs_dSp == 'y':
            # Scatter with the dSp scores vs Sp scores for targets and decoys. FDR and percentile lines are optional
            stats.scatter_dSp_vs_Sp(csv_files, args.lengths, args.Sp_cutoff, args.info_box,
                                    args.only_targets_with_decoys)
            save_graph("Scatter_dSp_Sp_{}.png".format(name_input))
            plt.close()

        # Edit the FDR table if additional targets (without decoys) are used in the plots
        if args.only_targets_with_decoys == 'n':
            stats.FDR_update(csv_files, args.lengths, args.Sp_cutoff, name_input)


def filename_from_path(path):
    """
    Extract the name of the output from the given input file
    """
    head, tail = ntpath.split(path)
    return tail or ntpath.basename(head)


if __name__ == "__main__":
    graphs_plot()
